---
title: "7 Proven Steps to Make an Untangable Mess of the New Android Project."
date: 2024-09-14
---

Hello, fellow developers! You may already be familiar with the recommendations below, but it is worth summarizing them in one place.

### Step 1: Choosing the right architecture

The first and most important step. Should you go with the MVP? MVVM? Or MVI? The secret is to **choose them all.**

### How to achieve this?

1. **Start with the Activity:**  
   Create a `MainActivity` that handles UI updates, manages state, and also fetches data from the repository. After all, why should we let ViewModels have all the fun? Let’s just throw them all into `MainActivity`.

2. **Create a Fragment for Everything:**  
   I mean **everything**. Each button click should navigate to a new fragment. Additionally, each fragment should have its own flavor—one with MVP, another with MVVM, and a third with MVI. The more inconsistent, the better.

3. **Introduce Business Logic in Views:**  
   Put some crucial business logic inside your custom views. Perhaps your `CustomButton` needs to know about user authentication? Sure, let it out. Spread logic everywhere.

4. **Avoid ViewModels and Repositories:**  
   Instead, put network calls directly in Activities and Fragments. The more places you have to look for a network call, the more interesting debugging will be. If anyone suggests using a `ViewModel`, remind them that it’s "overhead" and "too boilerplate-y."
   

### The Expected Outcomes

By the time you’ve implemented this step, your project will already be a labyrinth of interwoven dependencies, UI elements doing the work of the model layer, and activities that could fill Pulitzer-winning novel. Every future developers—or even future you—will spend  weeks just figuring out what’s going on than actually adding new features (оn the other hand, you are guaranteed to have some work to do).

### Next Steps

Stay tuned for **Step 2: The Dependency Injection Overload** where we’ll discuss how to turn a simple DI setup into an intricate maze of modules, providers, and ambiguous dependencies. Remember, the more `@Inject` annotations, the better!

Happy coding!
